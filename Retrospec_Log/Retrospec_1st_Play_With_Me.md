<details>
<summary><h1>(08/01) 월요일 필수 영상 정리</h1></summary>
<div markdown="1">
  
<details>
  <summary> <h2>HTTP 통신</h2> </summary>
<div markdown="1">

## HTTP란

<p>Hypertext Protocol : 서버-클라이언트 메시지 교환 프로토콜 <br>여기서 프로토콜이란 서로 다른 하드웨어 기기 간 데이터 통신 규약을 의미한다.</p>
<p>클라이언트 : 리소스를 요청하는 곳 (요청 : Request) <br> 
서버 : 해당 리소스를 제공해주는 곳 (응답 : Response)<br></p>
<b>클라이언트가 리소스를 HTTP를 통해 요청하면 TCP IP 프로토콜을 걸쳐 서버쪽의 HTTP까지 요청이 도달하는 과정을 통해 소통한다.</b>

### 통신과정

<image src = https://github.com/likelion-backendschool/Play_With_Me/blob/master/Retrospec_Log/image/http_tcp_ip.png width = 40%, height = 40%></img>

### TCP

<p>Transport 계층(서버와 클라이언트 사이 통신 연결 담당) 속의 프로토콜<br>
바이트 스트림(용량이 큰 데이터를 잘게 쪼갠 뒤 전송하는 서비스)과 3 Way HandShake를 통해 신뢰성 보장</p>
<p>3 Way HandShake : (나)내 목소리 들리니? (1)  (상대방)어 들려(응답, 2) (나)나도 잘 들려(3) -> 3번 왔다갔다 하는 과정을 반대편에서 응답이 올때 까지 진행하여 통신의 신뢰성을 보장</p>

### IP

<p>TCP로 신뢰성이 통과되면 데이터를 전송하게 됨, 앞서 IP주소와 MAC 주소를 통해 분할된 데이터 패킷들을 전송하게 됨</p>
<p>IP 주소는 믿기 어려움,(언제든 변경 가능, 도로명 주소), MAC 주소 (위도와 경도처럼 변하지 않는 것)<br>
대신 IP 주소를 통해 방향성을 얻을 수 있다.</p>
<p></p>

### DNS(Domain Name System)

<p>도메인 이름 및 IP 주소를 확인하는 기능 제공 (도메인 이름을 IP주소로 변환)</p>
<p>도메인 이름을 웹 브라우저에 입력할 때 최종 사용자를 어떤 서버에 연결할 지 제어함</p>

### URL과 URI 차이점

<p>URL : 웹페이지 상의 표시 주소<br> 
  URI : URL을 포괄한 개념으로 리소스를 식별하는 식별자</p>
  
  
  ## Request와 Response
  <p>Request message : 메서드, URI, 프로토콜 버전, 헤더, 바디로 구성</p>
  <p>Response message : 프로토콜 버전, 상태 코드, 상태코드에 대한 설명, 헤더, 바디로 구성</p>
  <p>HTTP Protocol은 Stateless 특성을 가짐 (상태가 없다) <br>
  &nbsp&nbsp-> 과거 정보를 저장 X, 새 request를 보낼 때마다 새로운 response보냄 (상태와 무관하여 확장이 쉬움)<br>
  &nbsp&nbsp-> 다만 정보를 저장해야만 할 때는 세션과 쿠키를 통해 상태를 저장함</p>
  <p>멱등성 : 연산을 여러번 적용해도 결과가 달라지지 않는 성질로 HTTP에서는 여러번 요청한 결과 서버의 상태가 항상 동일함을 뜻함</p>
  
  ### HTTP의 진화 과정
  <p>초기 HTTP는 비지속 연결을 사용&nbsp -> &nbsp보낼 것이 많아지고 자주 발생하여 자원 낭비와 속도 저하&nbsp -> &nbsp지속 연결 도입 (서버 부하 줄임)<br>
    -> &nbspresponse 응답을 기다리지 않고 곧바로 request를 보내는 파이프라이닝도 가능해짐(모던 브라우저에서는 사용X)</p>
  
  ### HTTP 요청 종류
  <p>GET 요청<br>
  : 데이터를 가져올때만 사용(바디 담는 게 금지X), 특정 리소스를 가져오도록 요청하는 것 -> 멱등성이 보장됨</p>

<p>POST 요청<br>
  : 대상 리소스에게 request 바디를 해당 리소스의 시맨틱에 따라 처리하도록 요청하는 것(게시판 블로그 글 작성) -> 멱등성 보장X</p>

<p>PUT 요청<br>
  : 대상 리소스가 없다면 생성 / 있을 경우 request의 바디대로 교체하는 데 사용됨 -> 멱등성 보장</p>

<p>PATCH 요청<br>
  : 리소스의 일부를 수정하는 데 사용 -> 멱등성 보장X</p>

<p>DELETE 요청<br>
  : 지정한 리소스를 삭제 -> 멱등성 보장</p>
  
  ### HTTP 상태코드
<p>1XX : 처리중 (해당 요청을 진행중) 잘 안 쓰인다.</p>
<p>2XX : 처리 성공 </p>
  
	* 200 : OK (서버가 요청을 제대로 처리함)
	* 201 : CREATE (200+새 리소스가 서버에 저장됨)
	* 204 : No Content (서버가 요청을 제대로 처리했지만 요청에 따른 콘텐츠를 제공하지 않을 때 사용)
<p>3XX : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.  (해당 처리를 할 수 있는 위치를 함께 알려줌) </p>
  
	* 304는 리다이렉트 X
<p>4XX : 잘못된 요청(에러) - 클라이언트</p>
  
	* 400 : Bad Request 서버가 요청의 구문을 인식하지 못했음(브라우저는 200과 같은 취급을 함)
	* 401 : Unauthorized 해당 요청을 위해서는 인증이 필요하다 (주로 로그인)
	* 403 : Forbidden 권한 없음 - 인증은 됐지만 사용자에게 권한이 없음
	* 404 : 그런 페이지 없음 - 요청을 거부하고 싶지만 이유가 비밀일때도 사용
<p>5XX : 서버 이상함(에러)</p>
  
	* 500 : Intener Server Error - 서버에 오류 발생하여 요청 수행이 불가능
	* 501 : Not Implemented - 서버에 요청을 수행할 수 있는 기능이 없을 때 사용 - 요청 메소드(Get, Post)를 인식하지 못할 때 사용
	* 503 : Service Unavailable - 서버가 다운됨. 서버의 유지보수로 사용 불가능, 과부하가 걸렸을 때 사용
<br><br>

</div>
</details>
  
  <details>
    <summary><h2>네트워크</h2></summary>
<div markdown="1">

## 네트워크

  <p>네트워크란 두 개 이상의 컴퓨터가 데이터를 주고 받을 수 있는 환경</p>
  <p>과거에는 데이터를 주고 받기 위해 플로피 디스크, 시디같은 저장 매체를 이용<br>
    -> 전선 케이블을 연결하여 정보를 주고 받는 방식이 등장<p>
  
  ### 인터넷
  <p>전선 케이블로 데이터 공유가 가능하자 여러대의 컴퓨터가 정보를 공유할 수 있도록 수많은 컴퓨터가 연결됨<br>
   -> 이렇게 그물망처럼 하나로 연결된 것을 인터넷이라한다.</p>
  
  ### 네트워크 구성요소
  
  * 단말 장치 : 데이터 송수신 장치 ex) 스마트폰 노트북, 컴퓨터 등
  * 전송 매체 : 단말 장치 끼리 데이터를 공유할 수 있도록 데이터를 전달해주는 매체 ex) LAN 케이블
  * 네트워크 장비 : 데이터가 최종 도착지까지 전달될 수 있도록 경로를 준비하는 네트워크 장비 ex) 허브, 스위치, 라우터
  
  ### 허브
  <p>하나의 네트워크에 여러 단말장치가 연결될 수 있도록 단말 수만큼 포트 수를 늘려 분배하는 역할만 수행 (lan포트에 연결)</p>
  <p>통신과정 : 하나의 단말장치는 출발지 MAC주소와 도착지 MAC주소를 적은 요청 메시지를 허브에게 전송<br> 
    -> 출발지 단말 장치를 제외한 모든 단말 장치에게 메시지를 전송 -> <br>
    메시지를 받은 단말 장치에서 도착지 정보를 확인 후 MAC주소와 일치하지 않으면 무시하고 일치하면 수신<br><br> </p>
  <b>=> 모든 단말장치에게 송신 후 메시지 받은 단말 장치에서 MAC주소 확인 후 일치하면 수신</b>
  
  ### 스위치
  <p>도착지 한곳에만 메시지를 보냄</p>
  <p>MAC 주소 테이블 : 포트를 알기 위해 스위치의 각 단말 장치의 위치를 적어둔 것 / 단말장치가 어느 포트에 연결되있는지를 나타냄</p>
  <p> 주소테이블 작성 과정은 수동으로 설정 가능, 대규모 네트워크의 경우 스위치 내부에서 자동으로 MAC주소를 알아내야함 <br>
    -> 이 과정을 ARP라 함</p>
  
  ### ARP (Address Resolution Protocol) : 주소 결정 프로토콜
  <p>단말장치 A에서 스위치에게 ARP요청 메시지를 송신<br>
    -> 출발지 포트가 2임을 확인하여 a가 2번 포트임을 확인하고 정보를 MAC 주소 테이블에 저장함<br>
    -> 해당 메시지를 받은 스위치는 A를 제외한 단말장치에게 받은 메시지를 복사하여 전달함 (Flooding과정)<br>
    -> ARP 요청메시지를 받은 단말장치는 IP정보를 확인하여 일치하면 ARP 응답 메시지를 스위치에게 전송<br>
    -> 이 과정을 통해 도착지 단말장치의 포트번호를 알아내 MAC 주소 테이블에 저장함</p>
    
  ### 라우터
  <p>서로 다른 네트워크의 사이를 중개하는 역할</p>
  <p>라우팅 테이블을 통해 네트워크 주소, 서브넷 마스크, 출력 인터페이스(포트 정보)를 정보로 가짐</p>
  
  ### 라우터를 통한 정보 전달 과정
  <p>한 단말장치에서 스위치에게 단말장치에게 메시지를 송신 <br>
  -> 해당 MAC 주소를 가진 단말장치가 없음을 확인하고 라우터에게 보냄<br>
  -> 라우터에서 도착지 IP와 서브넷 마스크를 통해 도착지 라우터를 찾음<br>
  -> 해당 라우터 내에 도착지 MAC주소를 다시 확인 하여 내부 스위치에게 메시지를 보냄<br>
  -> 해당 스위치의 MAC 주소 테이블을 통해 단말 장치를 찾아내어 요청을 전달함</p>

</div>
</details>
  </div>
</details>

<br>

<!-- 최승근 작성 -->
<details>
<summary><h1>(08/02) 화요일 필수 영상 정리</h1></summary>
<div markdown="1">
  
<details>
  <summary> <h2>HTTP 버전 별 발전과정과 차이</h2> </summary>
  <div markdown="1">

### 월드 와이드 웹의 발명

  <p>하이퍼테스트 문서를 표현하기 위한 텍스트 형식으로 시작되었다.</p><br>

### HTTP/0.9 - 원라인 프로토콜

  <p>HTTP의 초기버전으로 버전 정보가 없고, <b>차후 버전과 구별을 위해</b> HTTP/0.9로 불리게 되었다.</p><br>
  <p><b>요청 :</b> 단일 라인으로 구성되며 리소스에 대한 경로로 가능한 메서드는 GET이 유일했다.</p><br>
  <p><b>응답 :</b>오로지 파일 내용 자체로 구성</p>

### HTTP/1.1 - 표준 프로토콜

  <p>15년동안 사용된 첫 번째 표준 버전 <br>
  HTTP의 첫 번째 표준 버전으로 1.0 이 나온지 얼마안되어서 공개되었고 많은 개선사항을 도입했다.</p>
  <br>

#### HTTP/1.0

  <p>1995년부터 1.0 구현이 진행되었으며 합당한 표준화가 진행되었다.<br>
  <b>1.0 버전의 단점 : </b><br>HTTP 1.0은 TCP/IP를 기반으로 작동했는데 HTML, CSS 등 리소스를 가져올 때마다 연결, 연결해제, 재연결을 반복했다.</p>
   
  #### HTTP/1.1 의 변경점
  - <p><b>1.1 로 넘어오고 연결을 1회만 한다.</b><br>
  - 연결 또한 비용이 드는 행위인데 리소스들을 모두 가져온 후에 연결을 해제하기 때문에 연결에 대한 오버헤드가 줄어들었다.<br>
  - 커넥션이 재사용될 수 있게 하여, 탐색된 단일 원본 문서 내로 임베드된 리소스를 디스플레이하기 위해 사용된 커넥션을 다시 열어 시간을 절약할 수 있다.<br>
  - 헤더 덕분에 동일한 IP 주소에 다른 도메인을 호스트하는 기능이 서버 코로케이션을 가능케 한다. <br>
  <b>코로케이션 : </b>직접 서버를 관리를 하지 않고 인터넷 서비스를 제공하는 IDC 업체가 보유한 초고속 네트워크 망으로 서버를 연결하여 관리하는 서비스
  </p>

### HTTP/2.0 - 더 나은 성능을 위한 프로토콜

  <p>HTTP/1.1 이후로 15년 만에 나온 HTTP 프로토콜 버전<br></p>
    <p><b>중요한점 :</b><br>
      - 전송 계층으로 TCP를 사용한다. (HTTP/1.1 버전과 마찬가지)<br>
      - 구글의 개방형 네트워크 프로토콜인 SPDY(스피디)에 기반한다.<br>
      - 멀티 세션과 같은 개념을 지원 (IO Multiplexing 가능)
    </p>

  <p>클라이언트 서버 환경에서 유저모드 프로토콜의 전형적인 형태는 헤더 + 데이터 형태<br>
  HTTP 헤더의 덩치가 점점커지는데 2.0에서는 압축해버렸다. ⇒ Huffman Coding 방식<br><br>
  <b>멀티 플렉싱 : </b><br>
    - 하나의 통신 채널을 통해서 둘 이상의 데이터(시그널)를 전송하는데 사용되는 기술<br>
    - 물리적 장치의 효율성을 높이기 위해서 최소한의 물리적인 요소만 사용해서 최대한의 데이터를 전달하기 위해 사용되는 기술
    - 서버에 멀티플렉싱 기술 도입으로 필요한 프로세스의 수를 줄일 수 있다.
  </p>

<image src = https://github.com/likelion-backendschool/Play_With_Me/blob/master/Retrospec_Log/image/multiplexing.PNG width = 40%, height = 40%></img>

#### 차이점

  <p>
    - 1.1은 여러 개의 리소스가 있다면 앞의 리소스를 가져올 때까지 다음 리소스를 전송할 수 없다. 즉 줄세워 보내는 것이다.<br>
    - 2.0은 순서와 상관없이 리소스를 보내고 클라이언트에서 리소스의 순서를 조립한다.</p>

#### 개선사항

  <p><b>기존 내용 : </b><br>HTTP 1.1 커넥션은 올바른 순서로 전송되는 요청을 필요로하고 병렬 커넥션이 이론적으로 사용 가능한 경우 여전히 많은 오버헤드와 복잡도가 남아있었다.
  <b>변경 사항 : </b>SPDY 프로토콜을 구현하여 클라이언트 서버 간의 데이터 교환을 대체할 수있는 수단을 실증 하여 응답성 증가 능력을 입증하고 전송된 데이터 중복 관한 문제를 해결</p>

#### 결과

  <p>
    - 같은 조건에서 1.1과 2.0 를 비교하였을 때, 두 프로토콜은 극단적인 성능차이를 보인다<br>
    - IO Multiplexing으로 인한 성능과 속도가 좋아졌다.
  </p>

### HTTP/3.0 - UDP기반 전송 프로토콜의 등장

<p>가장 큰 핵심은 TCP 방법에서 UDP 방식으로 바뀌었다.</p><br>

#### 전송계층에서 사용되는 프로토콜

  <p>
    - TCP는 혼잡제어, 오류검사하기에 통신의 신뢰성이 높고, 속도상의 한계를 가지고 있다.<br>
    - UDP는 혼잡, 오류 제어를 하지 않고 빠른 속도를 가지고 있다.
  </p>

  <p>최근 웹의 데이터의 특징은<br>
    1. 데이터를 주고 받는데 특성상 바뀐 부분만을 압축해서 보낸다.<br>
    2. 실시간 환경에서 동영상, 음성 데이터는 일부의 데이터가 유실되어도 큰 영향이 없다.<br>
    => 따라서 이런 특징에 맞춰 <b>속도가 빠른 UDP</b>를 이용한다.
  </p>

##### 추가적인 내용

  <p>UDP방식이어도 제어와 관련된 부분은 상위계층에서 처리하기 때문에 어플리케이션 계층에서 혼잡제어를 재정의 할 수 있다. => QUIC</p>

  </div>
</details> <!-- 토글1 끝 -->

<details>
  <summary> <h2>서브네팅</h2> </summary>
  <div markdown="1">

### 서브네팅

  <p>네트워크를 내부의 네트워크로 나누는 것을 서브네팅이라고 한다.</p><br>

### IP 주소

  <p>IPv4 버전은 8bit씩 4개의로 총 32bit로 구성되어 있다. </p><br>
  <p>따라서 0.0.0.0 ~ 256.256.256.256 으로 표현 가능하다.</p><br>
  <p><b>IP 주소 클래스 :</b> 하나의 IP주소에서 네트워크 영역과 호스트 영역을 나누는 방법</p>

#### 특징

  <p>
    - C Class는 24개의 비트를 네트워크 아이디로 사용하고 나머지 8비트를 호스트 아이디로 사용<br>
    - 호스트 영역이 전부 0인 주소는 네트워크 주소를 위해 사용하지 못한다.<br>
    - 호스트 영역이 전부 1인 주소는 브로캐스팅을 위해 사용한다.<br>
  따라서 호스트 주소의 2개는 사용하지 못한다. => 실제로 사용 가능한 주소는 254개
  </p>

### 이해를 위한 설명

  <p><b>ISP(Internet Service Provide) :</b> 인터넷 서비스를 제공하는 업체를 의미<br>
  예를 들어 100개의 IP가 필요하다면 C클래스의 경우 154개의 IP가 낭비된다.<br>
  따라서 호스트 영역을 서브넷으로 분할하여 두 개의 네트워크(사유 공간)를 만든다.<br>
  비트연산으로 인해 1bit는 2개의 서브넷으로, 2bit는 4개의 서브넷으로 분할 가능하다.<br>
  서브넷으로 분할할 경우 호스트의 영역은 그만큼 작아진다.<br>
  - 8bit씩 표기하는 방법은 그대로이다. => 192.168.0.128, 192.168.0.192<br>
  </p>

#### 주요 특징

  <p>
    - 서브네팅을 하면 2개의 주소공간을 사용할 수 없다.<br>
      호스트 영역이 전부 0인 주소는 네트워크 주소로 호스트 영역이 전부 1인 주소는 브로드캐스팅 주소로 사용된다.<br>
    - 서브네팅은 나눠진 네트워크를 더 잘게 나눌 때 사용한다.
  <p>

### 서브네팅을 하는 이유 & 추가적인 내용

<p> 하나의 네트워크 주소를 여러 서브 네트워크(사적 공간)로 분할하여 사용하여 주소를 제공 받는 입장에서는 적당량의주소만큼을 받아 사용할 수 있다. <br>
네트워크를 나눔으로써 발생하는 오버헤드가 있을 수는 있을 수 있다.
</p>

#### 브로드 캐스팅 사용하는 이유

<p>
- ARP는 주소 결정 프로토콜로 IP주소를 기반으로 IP주소에 맞는 물리적 주소 MAC 찾아오는 프로토콜이다.
- 물리적 주소를 찾아오는 동작원리는 ARP 요청 패킷을 브로드캐스트로 모든 호스트에게 전송하여 물리주소를 받아온다. 따라서 브로드 캐스팅을 안할 수 없고 브로드캐스팅할 시 호스트가 많을 수록 효율은 떨어진다.</p>

  </div>
</details> <!-- 토글2 끝 -->

  </div>
</details>
<!-- 최승근 작성 완료 -->

<details>
<summary><h1>(08/03) 수요일 필수 영상 정리</h1></summary>
<div markdown="1">

- https://subsequent-shroud-fd5.notion.site/22-08-03-34-a0fc710501114c159296e3453a9e95df

</div>
</details>

<!-- 박범서 작성 완료 -->
<details>
<summary><h1>(08/04) 목요일 필수 영상 정리</h1></summary>
<div markdown="1">

- https://www.notion.so/22-08-04-35-88fdeb7c04cb4c8b97167785965467a6

</div>
</details>
